<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Actix Web | A powerful, pragmatic, and extremely fast web framework for Rust. on actix</title><link>https://actix.rs/</link><description>Recent content in Actix Web | A powerful, pragmatic, and extremely fast web framework for Rust. on actix</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><atom:link href="https://actix.rs/index.xml" rel="self" type="application/rss+xml"/><item><title>What is Actix</title><link>https://actix.rs/docs/whatis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/whatis/</guid><description>Actix is an Ecosystem of Crates Long ago, actix-web was built on top of actix, a powerful and fast actor system. Now, actix-web is largely unrelated to the actor framework and is built using a different system. Though actix is still maintained, its usefulness as a general tool is diminishing as the futures and async/await ecosystem matures. At this time, the use of actix it is only required for WebSocket endpoints.</description></item><item><title>Getting Started</title><link>https://actix.rs/docs/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/getting-started/</guid><description>Installing Rust If you don&amp;rsquo;t have Rust yet, we recommend you use rustup to manage your Rust installation. The official rust guide has a wonderful section on getting started.
Actix Web currently has a minimum supported Rust version (MSRV) of 1.42. Running rustup update will ensure you have the latest and greatest Rust version available. As such, this guide assumes you are running Rust 1.42 or later.
Hello, world! Start by creating a new binary-based Cargo project and changing into the new directory:</description></item><item><title>Application</title><link>https://actix.rs/docs/application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/application/</guid><description>Writing an Application actix-web provides various primitives to build web servers and applications with Rust. It provides routing, middleware, pre-processing of requests, post-processing of responses, etc.
All actix-web servers are built around the App instance. It is used for registering routes for resources and middleware. It also stores application state shared across all handlers within the same scope.
An application&amp;rsquo;s scope acts as a namespace for all routes, i.e. all routes for a specific application scope have the same url path prefix.</description></item><item><title>Server</title><link>https://actix.rs/docs/server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/server/</guid><description>The HTTP Server The HttpServer type is responsible for serving HTTP requests.
HttpServer accepts an application factory as a parameter, and the application factory must have Send + Sync boundaries. More about that in the multi-threading section.
To bind to a specific socket address, bind() must be used, and it may be called multiple times. To bind ssl socket, bind_openssl() or bind_rustls() should be used. To run the HTTP server, use the HttpServer::run() method.</description></item><item><title>Handlers</title><link>https://actix.rs/docs/handlers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/handlers/</guid><description>Request Handlers A request handler is an async function that accepts zero or more parameters that can be extracted from a request (ie, impl FromRequest) and returns a type that can be converted into an HttpResponse (ie, impl Responder).
Request handling happens in two stages. First the handler object is called, returning any object that implements the Responder trait. Then, respond_to() is called on the returned object, converting itself to a HttpResponse or Error.</description></item><item><title>Extractors</title><link>https://actix.rs/docs/extractors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/extractors/</guid><description>Type-safe information extraction Actix-web provides a facility for type-safe request information access called extractors (ie, impl FromRequest). By default, actix-web provides several extractor implementations.
An extractor can be accessed as an argument to a handler function. Actix-web supports up to 10 extractors per handler function. Argument position does not matter.
asyncfn index(path: web::Path&amp;lt;(String,String)&amp;gt;,json: web::Json&amp;lt;MyInfo&amp;gt;)-&amp;gt; implResponder{letpath=path.into_inner();format!(&amp;#34;{} {} {} {}&amp;#34;,path.0,path.1,json.id,json.username)} Path Path provides information that can be extracted from the Request&amp;rsquo;s path. You can deserialize any variable segment from the path.</description></item><item><title>Errors</title><link>https://actix.rs/docs/errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/errors/</guid><description>Errors Actix-web uses its own actix_web::error::Error type and actix_web::error::ResponseError trait for error handling from web handlers.
If a handler returns an Error (referring to the general Rust trait std::error::Error) in a Result that also implements the ResponseError trait, actix-web will render that error as an HTTP response with it&amp;rsquo;s corresponding actix_web::http::StatusCode. Internal server error is generated by default:
pubtraitResponseError{fn error_response(&amp;amp;self)-&amp;gt; Response&amp;lt;Body&amp;gt;;fn status_code(&amp;amp;self)-&amp;gt; StatusCode;}A Responder coerces compatible Results into HTTP responses:</description></item><item><title>URL Dispatch</title><link>https://actix.rs/docs/url-dispatch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/url-dispatch/</guid><description>URL Dispatch URL dispatch provides a simple way for mapping URLs to handler code using a simple pattern matching language. If one of the patterns matches the path information associated with a request, a particular handler object is invoked.
A request handler is a function that accepts zero or more parameters that can be extracted from a request (ie, impl FromRequest) and returns a type that can be converted into an HttpResponse (ie, impl Responder).</description></item><item><title>Requests</title><link>https://actix.rs/docs/request/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/request/</guid><description>Content Encoding Actix-web automatically decompresses payloads. The following codecs are supported:
Brotli Chunked Compress Gzip Deflate Identity Trailers EncodingExt If request headers contain a Content-Encoding header, the request payload is decompressed according to the header value. Multiple codecs are not supported, i.e: Content-Encoding: br, gzip.
JSON Request There are several options for json body deserialization.
The first option is to use Json extractor. First, you define a handler function that accepts Json&amp;lt;T&amp;gt; as a parameter, then, you use the .</description></item><item><title>Responses</title><link>https://actix.rs/docs/response/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/response/</guid><description>Response A builder-like pattern is used to construct an instance of HttpResponse. HttpResponse provides several methods that return a HttpResponseBuilder instance, which implements various convenience methods for building responses.
Check the documentation for type descriptions.
The methods .body, .finish, and .json finalize response creation and return a constructed HttpResponse instance. If this methods is called on the same builder instance multiple times, the builder will panic.
useactix_web::HttpResponse;asyncfn index()-&amp;gt; HttpResponse{HttpResponse::Ok().</description></item><item><title>Testing</title><link>https://actix.rs/docs/testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/testing/</guid><description>Testing Every application should be well tested. Actix-web provides tools to perform unit and integration tests.
Unit Tests For unit testing, actix-web provides a request builder type. TestRequest implements a builder-like pattern. You can generate a HttpRequest instance with to_http_request() and call your handler with it.
#[cfg(test)]mod tests{usesuper::*;useactix_web::{http,test};#[actix_rt::test]asyncfn test_index_ok(){letreq=test::TestRequest::with_header(&amp;#34;content-type&amp;#34;,&amp;#34;text/plain&amp;#34;).to_http_request();letresp=index(req).await;assert_eq!(resp.status(),http::StatusCode::OK);}#[actix_rt::test]asyncfn test_index_not_ok(){letreq=test::TestRequest::default().to_http_request();letresp=index(req).await;assert_eq!(resp.status(),http::StatusCode::BAD_REQUEST);}} Integration tests There are a few methods for testing your application. Actix-web can be used to run the application with specific handlers in a real HTTP server.</description></item><item><title>Middleware</title><link>https://actix.rs/docs/middleware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/middleware/</guid><description>Middleware Actix-web&amp;rsquo;s middleware system allows us to add additional behavior to request/response processing. Middleware can hook into an incoming request process, enabling us to modify requests as well as halt request processing to return a response early.
Middleware can also hook into response processing.
Typically, middleware is involved in the following actions:
Pre-process the Request Post-process a Response Modify application state Access external services (redis, logging, sessions) Middleware is registered for each App, scope, or Resource and executed in opposite order as registration.</description></item><item><title>Static Files</title><link>https://actix.rs/docs/static-files/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/static-files/</guid><description>Individual file It is possible to serve static files with a custom path pattern and NamedFile. To match a path tail, we can use a [.*] regex.
useactix_files::NamedFile;useactix_web::{HttpRequest,Result};usestd::path::PathBuf;asyncfn index(req: HttpRequest)-&amp;gt; Result&amp;lt;NamedFile&amp;gt;{letpath: PathBuf=req.match_info().query(&amp;#34;filename&amp;#34;).parse().unwrap();Ok(NamedFile::open(path)?)}#[actix_web::main]asyncfn main()-&amp;gt; std::io::Result&amp;lt;()&amp;gt;{useactix_web::{web,App,HttpServer};HttpServer::new(||App::new().route(&amp;#34;/{filename:.*}&amp;#34;,web::get().to(index))).bind(&amp;#34;127.0.0.1:8080&amp;#34;)?.run().await} Directory To serve files from specific directories and sub-directories, Files can be used. Files must be registered with an App::service() method, otherwise it will be unable to serve sub-paths.
useactix_filesasfs;useactix_web::{App,HttpServer};#[actix_web::main]asyncfn main()-&amp;gt; std::io::Result&amp;lt;()&amp;gt;{HttpServer::new(||{App::new().service(fs::Files::new(&amp;#34;/static&amp;#34;,&amp;#34;.&amp;#34;).show_files_listing())}).bind(&amp;#34;127.0.0.1:8080&amp;#34;)?.run().await} By default files listing for sub-directories is disabled.</description></item><item><title>Websockets</title><link>https://actix.rs/docs/websockets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/websockets/</guid><description>Actix-web supports WebSockets with the actix-web-actors crate. It is possible to convert a request&amp;rsquo;s Payload to a stream of ws::Message with a web::Payload and then use stream combinators to handle actual messages, but it is simpler to handle websocket communications with an http actor.
The following is an example of a simple websocket echo server:
useactix::{Actor,StreamHandler};useactix_web::{web,App,Error,HttpRequest,HttpResponse,HttpServer};useactix_web_actors::ws;/// Define HTTP actor struct MyWs;implActorforMyWs{type Context=ws::WebsocketContext&amp;lt;Self&amp;gt;;}/// Handler for ws::Message message implStreamHandler&amp;lt;Result&amp;lt;ws::Message,ws::ProtocolError&amp;gt;&amp;gt;forMyWs{fn handle(&amp;amp;mutself,msg: Result&amp;lt;ws::Message,ws::ProtocolError&amp;gt;,ctx: &amp;amp;mutSelf::Context,){matchmsg{Ok(ws::Message::Ping(msg))=&amp;gt;ctx.pong(&amp;amp;msg),Ok(ws::Message::Text(text))=&amp;gt;ctx.text(text),Ok(ws::Message::Binary(bin))=&amp;gt;ctx.binary(bin),_=&amp;gt;(),}}}asyncfn index(req: HttpRequest,stream: web::Payload)-&amp;gt; Result&amp;lt;HttpResponse,Error&amp;gt;{letresp=ws::start(MyWs{},&amp;amp;req,stream);println!</description></item><item><title>HTTP/2</title><link>https://actix.rs/docs/http2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/http2/</guid><description>actix-web automatically upgrades connections to HTTP/2 if possible.
Negotiation HTTP/2 protocol over TLS without prior knowledge requires TLS ALPN.
Currently, only rust-openssl has support.
alpn negotiation requires enabling the feature. When enabled, HttpServer provides the bind_openssl method.
[dependencies] actix-web = { version = &amp;#34;3&amp;#34;, features = [&amp;#34;openssl&amp;#34;] } openssl = { version = &amp;#34;0.10&amp;#34;, features = [&amp;#34;v110&amp;#34;] } useactix_web::{web,App,HttpRequest,HttpServer,Responder};useopenssl::ssl::{SslAcceptor,SslFiletype,SslMethod};asyncfn index(_req: HttpRequest)-&amp;gt; implResponder{&amp;#34;Hello.&amp;#34;}#[actix_web::main]asyncfn main()-&amp;gt; std::io::Result&amp;lt;()&amp;gt;{// load ssl keys // to create a self-signed temporary cert for testing: // `openssl req -x509 -newkey rsa:4096 -nodes -keyout key.</description></item><item><title>Auto-Reloading</title><link>https://actix.rs/docs/autoreload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/autoreload/</guid><description>Auto-Reloading Development Server During development it can be very handy to have cargo automatically recompile the code on changes. This can be accomplished very easily by using cargo-watch.
cargo watch -x &amp;#39;run --bin app&amp;#39; Historical Note An old version of this page recommended using a combination of systemfd and listenfd, but this has many gotchas and was difficult to integrate properly, especially when part of a broader development workflow. We consider cargo-watch to be sufficient for auto-reloading purposes.</description></item><item><title>Databases</title><link>https://actix.rs/docs/databases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/databases/</guid><description>Async Options We have several example projects showing use of async database adapters:
SQLx: https://github.com/actix/examples/tree/master/database_interactions/sqlx_todo Postgres: https://github.com/actix/examples/tree/master/database_interactions/pg SQLite: https://github.com/actix/examples/tree/master/database_interactions/basic Diesel The current version of Diesel (v1) does not support asynchronous operations, so it is important to use the web::block function to offload your database operations to the Actix runtime thread-pool.
You can create action functions that correspond to all the operations your app will perform on the database.</description></item><item><title>HTTP Server Initialization</title><link>https://actix.rs/docs/http_server_init/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/http_server_init/</guid><description>Architecture overview Below is a diagram of HttpServer initialization, which happens on the following code
#[actix_web::main]asyncfn main()-&amp;gt; std::io::Result&amp;lt;()&amp;gt;{HttpServer::new(||{App::new().</description></item><item><title>Connection Lifecycle</title><link>https://actix.rs/docs/conn_lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/docs/conn_lifecycle/</guid><description>Architecture overview After Server has started listening to all sockets, Accept and Worker are two main loops responsible for processing incoming client connections.
Once connection accepted Application level protocol processing happens in a protocol specific Dispatcher loop spawned from Worker.
Please note, below diagrams are outlining happy-path scenarios only. Accept loop in more detail Most of code implementation resides in actix-server crate for struct Accept.
Worker loop in more detail Most of code implementation resides in actix-server crate for struct Worker.</description></item><item><title>Contributor Covenant Code of Conduct</title><link>https://actix.rs/community/coc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://actix.rs/community/coc/</guid><description>Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.
Our Standards Examples of behavior that contributes to creating a positive environment include:
Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include:</description></item></channel></rss>